# 线程的生命周期

![](https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210715224539.png)

# 线程的同步

## 买票问题（``WindowTest*``）

**例子：创建三个窗口卖票，总票数为 100 张.使用实现 Runnable 接口的方式**

1. 问题：卖票过程中，出现了重票、错票 --> 说明出现了线程的安全问题
2. 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。
3. 如何解决：当一个线程 a 在操作 ticket 的时候，通过某种方法使其他线程不能参与进来。直到线程 a 操作完 ticket 时，其他线程才可以开始操作 ticket。这种情况即使线程 a 出现了阻塞，也不能被改变。

在 Java 中，我们通过同步机制，来解决线程的安全问题。

==方式一：同步代码块==

```cpp
synchronized(同步监视器){
   // 需要被同步的代码
}
```

> 说明：
>
> 1）操作共享数据的代码，即为需要被同步的代码。  --> 不能包含代码多了，也不能包含代码少了。  
>
> 2）共享数据：多个线程共同操作的变量。比如：ticket 就是共享数据。
>
> 3）同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
> 		要求：多个线程必须要共用同一把锁。
>
> PS：在实现 Runnable 接口创建多线程的方式中，我们可以考虑使用 this 充当同步监视器。

==方式二：同步方法==
	如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

> 关于同步方法的总结：
>
> 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
> 2. 非静态的同步方法，同步监视器是：this
>    静态的同步方法，同步监视器是：当前类本身

==方式三：Lock 锁 —— JDK5.0 新增==

```cpp
class Window implements Runnable {
    private int ticket = 100;
    private ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
        try {
            // 2.调用 sock
            lock.lock();

            if (ticket > 0) {

                try {  // 手动增加线程切换的概率
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println(Thread.currentThread().getName() + "：售票，票号为：" + ticket);
                ticket--;
            } else {
                break;
            }
        } finally {
            // 3.调用解锁方法
            lock.unlock();
        }
    }
}
```

同步的好与坏：

- 同步的方式，解决了线程的安全问题 ———— 好处
- 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低 ———— 局限性

## 问题

synchronized 和 Lock 的区别是什么？

答：同：二者都可以解决线程安全问题；
异：synchronized 机制在执行完相应的同步代码以后，自动的释放同步监视器，Lock 需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）。

PS：优先使用顺序：Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方法体之外）

# 线程的死锁问题

- 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
- 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续

# 线程的通信

涉及到的三个方法：

- wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
- notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
- notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。

wait()，notify()，notifyAll() 三个方法的说明：

1. 必须使用在同步代码块或同步方法中（Lock 方式同步还有其他方法）；
2. 调用者必须是同步代码块或同步方法中的同步监视器，否则，会出现IllegalMonitorStateException异常；
3. 定义在 java.lang.Object 类中；

## 生产者和消费者

生产者 Productor 将产品交给店员 ( Clerk），而消费者 ( 从店员处取走产品，店员一次只能持有固定数量的产品 比如 20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。



## 问题

sleep() 和 wait() 的异同？

- 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
- 不同点：1）两个方法声明的位置不同：Thread 类中声明 sleep() , Object 类中声明 wait()
      2）调用的要求不同：sleep() 可以在任何需要的场景下调用。 wait() 必须使用在同步代码块或同步方法中
      3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep() 不会释放锁，wait() 会释放锁。

